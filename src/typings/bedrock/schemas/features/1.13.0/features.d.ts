/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Specifies the version of the game this entity was made in. Minimum supported version is 1.13.0. Current supported version is 1.13.0.
 */
export type FormatVersion = "1.13.0";
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier = string;
/**
 * Collection of features to be placed one by one. No guarantee of order. All features use the same input position.
 *
 * @minItems 1
 */
export type Features = [Feature, ...Feature[]];
/**
 * UNDOCUMENTED.
 */
export type Feature = string;
/**
 * LIKELY TO BE CHANGED: Do not continue placing features once either the first success or first failure has occurred.
 */
export type EarlyOut = "none" | "first_failure" | "first_success";
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier1 = string;
/**
 * Named reference of feature to be placed.
 */
export type PlacesFeature = string;
/**
 * Dimensions of the Bounding Box.
 */
export type BoundingBoxMin = [] | [X] | [X, Y] | [X, Y, Z];
export type X = number;
export type Y = number;
export type Z = number;
/**
 * Dimensions of the Bounding Box.
 */
export type BoundingBoxMax = [] | [X1] | [X1, Y1] | [X1, Y1, Z1];
export type X1 = number;
export type Y1 = number;
export type Z1 = number;
/**
 * Y Delta for BAS.
 */
export type YDelta = number;
/**
 * Reference to the block to be placed.
 */
export type SurfaceBlockType = string;
/**
 * Reference to the block to be placed.
 */
export type SubsurfaceBlockType = string;
/**
 * Y Delta for BAS.
 */
export type BeardRaggednessMin = number;
/**
 * Y Delta for BAS.
 */
export type BeardRaggednessMax = number;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier2 = string;
/**
 * Reference to the block to fill the cave with.
 */
export type FillWith = string;
/**
 * How many blocks to increase the cave radius by, from the center point of the cave.
 */
export type WidthModifier = string | number;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier3 = string;
/**
 * Feature to be placed.
 */
export type PlacesFeature1 = string;
/**
 * Condition for placing associated Feature.
 */
export type Condition = string;
/**
 * Array of Features, and their associated Conditions, for attempted placement. These features will be evaluated as ordered.
 */
export type ConditionalFeatures = ConditionalFeature[];
/**
 * Denote whether placement should end on first successful placement or first passed condition.
 */
export type EarlyOutScheme = "condition_success" | "placement_success";
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier4 = string;
/**
 * The block to fill the inside of the geode.
 */
export type Filler = string;
/**
 * The block that forms the inside layer of the geode shell.
 */
export type InnerLayer = string;
/**
 * The block that has a chance of generating instead of inner_layer.
 */
export type AlternateInnerLayer = string;
/**
 * The block that forms the middle layer of the geode shell.
 */
export type MiddleLayer = string;
/**
 * The block that forms the outer shell of the geode.
 */
export type OuterLayer = string;
/**
 * A list of blocks that may be replaced during placement. Omit this field to allow any block to be replaced.
 *
 * @minItems 1
 */
export type InnerPlacements = [BlockReference, ...BlockReference[]];
/**
 * A block that may be replaced during placement.
 */
export type BlockReference = string;
/**
 * The minimum distance each distribution point must be from the outer wall. [0,10]
 */
export type MinimumOuterWallDistance = number;
/**
 * The maximum distance each distribution point can be from the outer wall. [0,20]
 */
export type MaximumOuterWallDistance = number;
/**
 * The minimum number of points inside the distance field that can get generated. The distance field is the area consisting of all points with a minimum distance to all destribution points. [0,10]
 */
export type MinimumDistributionPoints = number;
/**
 * The maximum number of points inside the distance field that can get generated. The distance field is the area consisting of all points with a minimum distance to all destribution points. [0,20]
 */
export type MaximumDistributionPoints = number;
/**
 * The lowest possible value of random offset applied to the position of each distribution point. [0,10]
 */
export type MinimumPointOffset = number;
/**
 * The highest possible value of random offset applied to the position of each distribution point. [0,10]
 */
export type MaximumPointOffset = number;
/**
 * The maximum possible radius of the geode generated.
 */
export type MaximumRadius = number;
/**
 * An offset applied to each distribution point that forms the geode crack opening. [0,10]
 */
export type CrackPointOffset = number;
/**
 * The likelihood of a geode generating with a crack in its shell. [0,1]
 */
export type GenerateCrackChance = number;
/**
 * How large the crack opening of the geode should be when generated. [0,5]
 */
export type BaseCrackSize = number;
/**
 * A multiplier applied to the noise that is applied to the distribution points within the geode. Higher = more noisy.
 */
export type NoiseMultiplier = number;
/**
 * The likelihood that a special block will be placed on the inside of the geode. [0,1]
 */
export type UsePotentialPlacementsChance = number;
/**
 * The likelihood that a block in the innermost layer of the geode will be replaced with an alternate option. [0,1]
 */
export type UseAlternateLayer0Chance = number;
/**
 *  If true, the potential placement block will only be placed on the alternate layer0 blocks that get placed. Potential placement blocks are blocks that depend on the existance of another block to be placed. The latter are the layer0 alternate blocks.
 */
export type PlacementsRequireLayer0Alternate = boolean;
/**
 * The threshold of invalid blocks for a geode to have a distribution point in before it aborts generation entirely.
 */
export type InvalidBlocksThreshold = number;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier5 = string;
/**
 * Age of the head of the plant.
 */
export type Age = number | Range;
/**
 * The maximum plant height.
 */
export type RangeMax = number;
/**
 * The minimum plant height.
 */
export type RangeMin = number;
/**
 * Collection of weighted heights that placement will select from.
 *
 * @minItems 1
 */
export type HeightDistribution = [HeightDistribution1, ...HeightDistribution1[]];
/**
 * Collection of weighted heights that placement will select from.
 *
 * @minItems 2
 * @maxItems 2
 */
export type HeightDistribution1 = [PlantHeight, Weight];
/**
 * Plant height.
 */
export type PlantHeight = number | Range;
/**
 * Weight used in random selection. Value is relative to other weights in the collection.
 */
export type Weight = number;
/**
 * Direction that the plant grows towards. Valid values: UP and DOWN
 */
export type GrowthDirection = "UP" | "DOWN" | "up" | "down";
/**
 * Collection of weighted block descriptor that placement will select from for the body of the plant.
 *
 * @minItems 1
 */
export type BodyBlocks = [Blocks, ...Blocks[]];
/**
 * Collection of weighted block descriptor that placement will select from for the plant.
 *
 * @minItems 2
 * @maxItems 2
 */
export type Blocks = [PlantBodyBlock, Weight1];
/**
 * Plant body block.
 */
export type PlantBodyBlock = string;
/**
 * Weight used in random selection. Value is relative to other weights in the collection.
 */
export type Weight1 = number;
/**
 * Collection of weighted block descriptor that placement will select from for the body of the plant.
 *
 * @minItems 1
 */
export type HeadBlocks = [Blocks, ...Blocks[]];
/**
 * Plant blocks can be placed in water.
 */
export type AllowWater = boolean;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier6 = string;
/**
 * Reference to the block to fill the cave with.
 */
export type Identifier7 = string;
/**
 * How many blocks to increase the cave radius by, from the center point of the cave.
 */
export type Identifier8 = string | number;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier9 = string;
/**
 * Reference to the block to be placed.
 */
export type PlacesBlock = string;
/**
 * How far, in blocks, this feature can search for a valid position to place.
 */
export type SearchRange = number;
/**
 * Can this feature be placed on the ground (top face of a block)?.
 */
export type CanPlaceOnFloor = boolean;
/**
 * Can this feature be placed on the ceiling (bottom face of a block)?.
 */
export type CanPlaceOnCeiling = boolean;
/**
 * Can this feature be placed on the wall (side faces of a block)?.
 */
export type CanPlaceOnWall = boolean;
/**
 * For each block placed by this feature, how likely will that block spread to another?.
 */
export type ChanceOfSpreading = number;
/**
 *  How far, in blocks, this feature can search for a valid position to place.
 *
 * @minItems 1
 */
export type CanPlaceOn = [Block, ...Block[]];
/**
 *  A list of blocks that the block in this feature can be placed on. Omit this field to allow any block to be placed on.
 */
export type Block = string;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier10 = string;
/**
 * The number of blocks to be placed.
 */
export type Count = number;
/**
 * Collection of replace rules that will be checked in order of definition. If a rule is resolved, the rest will not be resolved for that block position.
 *
 * @minItems 1
 */
export type ReplaceRules = [RepalceRule, ...RepalceRule[]];
/**
 * Reference to the block to be placed.
 */
export type PlacesBlock1 = string;
/**
 * A list of blocks that may be replaced during placement. Omit this field to allow any block to be replaced.
 *
 * @minItems 1
 */
export type MayReplace = [BlockIdentifier, ...BlockIdentifier[]];
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier = string;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier11 = string;
/**
 * Ratio of a Chunk to be filled with empty space rather than features.
 */
export type RatioOfEmptySpace = number;
/**
 * UNDOCUMENTED.
 *
 * @minItems 1
 * @maxItems 4294967295
 */
export type FeatureAreas = [FeatureArea, ...FeatureArea[]];
/**
 * Feature to be placed.
 */
export type Feature1 = string;
/**
 * Dimensions (size) of the associated Feature.
 *
 * @minItems 2
 * @maxItems 2
 */
export type AreaDimensions = [Width, Length];
export type Width = number;
export type Length = number;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier12 = string;
/**
 * Named reference of feature to be placed.
 */
export type ScanSurfaceFeature = string;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier13 = string;
/**
 * Named reference of feature to be placed.
 */
export type PlacesFeature2 = string;
/**
 * If true, snaps the y-value of the scattered position to the terrain heightmap. If false or unset, y-value is unmodified.
 */
export type ProjectInputToFloor = boolean;
/**
 * Number of scattered positions to generate.
 */
export type Iterations = string | number;
export type ScatterChance =
  | {
      numerator?: Numerator;
      denominator?: Denominator;
    }
  | MolangNumber;
/**
 * UNDOCUMENTED.
 */
export type Numerator = number;
/**
 * UNDOCUMENTED.
 */
export type Denominator = number;
/**
 * Probability (0-100] that this scatter will occur. Not evaluated each iteration; either no iterations will run, or all will.
 */
export type MolangNumber = string | number;
/**
 * The order in which coordinates will be evaluated. Should be used when a coordinate depends on another. If omitted, defaults to `xzy`.
 */
export type CoordinateEvalOrder = "xyz" | "xzy" | "yxz" | "yzx" | "zxy" | "zyx";
export type X2 =
  | MolangNumber1
  | {
      distribution: Distribution;
      step_size?: StepSize;
      grid_offset?: StepSize1;
      extent: Extent;
    };
/**
 * Expression for the coordinate (evaluated each iteration). Mutually exclusive with random distribution object below.
 */
export type MolangNumber1 = string | number;
/**
 * Type of distribution - uniform random, gaussian (centered in the range), or grid (either fixed-step or jittered).
 */
export type Distribution = "uniform" | "gaussian" | "inverse_gaussian" | "fixed_grid" | "jittered_grid";
/**
 * When the distribution type is grid, defines the distance between steps along this axis.
 */
export type StepSize = number;
/**
 * When the distribution type is grid, defines the offset along this axis.
 */
export type StepSize1 = number;
/**
 * UNDOCUMENTED.
 */
export type Extent = [] | [LowerBound] | [LowerBound, UpperBound];
/**
 * Lower bound (inclusive) of the scatter range, as an offset from the input point to scatter around.
 */
export type LowerBound = string | number;
/**
 * Upper bound (inclusive) of the scatter range, as an offset from the input point to scatter around.
 */
export type UpperBound = string | number;
export type X3 =
  | MolangNumber1
  | {
      distribution: Distribution;
      step_size?: StepSize;
      grid_offset?: StepSize1;
      extent: Extent;
    };
export type X4 =
  | MolangNumber1
  | {
      distribution: Distribution;
      step_size?: StepSize;
      grid_offset?: StepSize1;
      extent: Extent;
    };
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier14 = string;
/**
 * Named reference of feature to be placed.
 */
export type PlacesFeature3 = string;
/**
 * Maximum extent of the bounding volume expressed as [ x, y, z ].
 */
export type Max = [] | [MaximumX] | [MaximumX, MaximumY] | [MaximumX, MaximumY, MaximumZ];
export type MaximumX = number;
export type MaximumY = number;
export type MaximumZ = number;
/**
 * Maxium extent of the bounding volume expressed as [ x, y, z ].
 */
export type Min = [] | [MinimumX] | [MinimumX, MinimumY] | [MinimumX, MinimumY, MinimumZ];
export type MinimumX = number;
export type MinimumY = number;
export type MinimumZ = number;
/**
 * Axis that the search will sweep along through the `search_volume`.
 */
export type SearchAxis = "-x" | "+x" | "-y" | "+y" | "-z" | "+z";
/**
 * Number of valid positions the search must find in order to place the referenced feature.
 */
export type RequiredSuccesses = number;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier15 = string;
/**
 * List of features to be placed in sequence. The output position of the previous feature is used as the input position to the next.
 *
 * @minItems 1
 */
export type Features1 = [Feature2, ...Feature2[]];
/**
 * A feature to be placed in sequence. The output position of the previous feature is used as the input position to the next.
 */
export type Feature2 = string;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier16 = string;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier1 = string;
/**
 * If true, enforce the block's canPlace check.
 */
export type EnforcePlacementRules = boolean;
/**
 * If true, enforce the block's canSurvive check.
 */
export type EnforceSurvivabilityRules = boolean;
/**
 * UNDOCUMENTED.
 */
export type Top = string | BlockSide[];
/**
 * UNDOCUMENTED.
 */
export type BlockSide = string;
/**
 * UNDOCUMENTED.
 */
export type Bottom = string | BlockSide[];
/**
 * UNDOCUMENTED.
 */
export type North = string | BlockSide[];
/**
 * UNDOCUMENTED.
 */
export type South = string | BlockSide[];
/**
 * UNDOCUMENTED.
 */
export type East = string | BlockSide[];
/**
 * UNDOCUMENTED.
 */
export type West = string | BlockSide[];
/**
 * UNDOCUMENTED.
 */
export type All = string | BlockSide[];
/**
 * UNDOCUMENTED.
 */
export type Sides = string | BlockSide[];
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier2 = string;
/**
 * A list of blocks that may be replaced during placement. Omit this field to allow any block to be replaced.
 */
export type MayReplace1 = BlockIdentifier2[];
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier17 = string;
/**
 * Named reference of feature to be snapped.
 */
export type FeatureToSnap = string;
/**
 * Range to search for a floor or ceiling for snaping the feature.
 */
export type VerticalSearchRange = number;
/**
 * Defines the surface that the y-value of the placement position will be snapped to. Valid values: `ceiling` and `floor'
 */
export type Surface = "ceiling" | "floor";
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier18 = string;
/**
 * Reference to the structure to be placed.
 */
export type StructureName = string;
/**
 * How far the structure is allowed to move when searching for a valid placement position. Search is radial, stopping when the nearest valid position is found. Defaults to 0 if omitted.
 */
export type AdjustmentRadius = number;
/**
 * Direction the structure will face when placed in the world. Defaults to `random` if omitted.
 */
export type FacingDirection = "north" | "south" | "east" | "west" | "random";
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier3 = string;
/**
 * List of blocks the owning structure is allowed to intersect with.
 */
export type BlockAllowlist = BlockIdentifier3[];
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier4 = string;
/**
 * List of blocks the owning structure is allowed to intersect with.
 */
export type BlockWhitelist = BlockIdentifier4[];
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier19 = string;
export type BaseBlock = BlockIdentifier | BlockIdentifier5[];
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier5 = string;
/**
 * UNDOCUMENTED.
 */
export type MayReplace2 = BlockIdentifier[];
/**
 * UNDOCUMENTED.
 */
export type NumClusters = number;
/**
 * UNDOCUMENTED.
 */
export type ClustersRadius = number;
/**
 * UNDOCUMENTED.
 */
export type MayGrowOn = BlockIdentifier[];
/**
 * UNDOCUMENTED.
 */
export type MayGrowOn1 = BlockIdentifier[];
/**
 * UNDOCUMENTED.
 */
export type MayGrowOn2 = BlockIdentifier[];
/**
 * UNDOCUMENTED.
 */
export type TrunkWidth = number;
/**
 * UNDOCUMENTED.
 */
export type Base = number;
/**
 * UNDOCUMENTED.
 *
 * @minItems 1
 */
export type Intervals = [number, ...number[]];
/**
 * UNDOCUMENTED.
 */
export type MinimumHeightForCanopy = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier6 = string;
/**
 * UNDOCUMENTED.
 */
export type BranchLength = number;
/**
 * UNDOCUMENTED.
 */
export type BranchPosition = number;
/**
 * UNDOCUMENTED.
 */
export type Numerator1 = number;
/**
 * UNDOCUMENTED.
 */
export type Denominator1 = number;
/**
 * UNDOCUMENTED.
 */
export type CanopySize = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier7 = string;
/**
 * UNDOCUMENTED.
 */
export type SimplifyCanopy = boolean;
/**
 * UNDOCUMENTED.
 */
export type Min1 = number;
/**
 * UNDOCUMENTED.
 */
export type Max1 = number;
/**
 * UNDOCUMENTED.
 */
export type MinWidth = number;
/**
 * UNDOCUMENTED.
 */
export type Rise = number;
/**
 * UNDOCUMENTED.
 */
export type Run = number;
/**
 * UNDOCUMENTED.
 */
export type VariationChance = ChanceInformation1 | number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier8 = string;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier9 = string;
/**
 * UNDOCUMENTED.
 */
export type NumSteps = number;
/**
 * UNDOCUMENTED.
 */
export type StepDirection = "down" | "up" | "out" | "away";
/**
 * UNDOCUMENTED.
 */
export type Height = number;
/**
 * UNDOCUMENTED.
 */
export type Radius = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier10 = string;
/**
 * UNDOCUMENTED.
 */
export type CanopyHeight = number;
/**
 * UNDOCUMENTED.
 */
export type BaseRadius = number;
/**
 * UNDOCUMENTED.
 */
export type CoreWidth = number;
/**
 * UNDOCUMENTED.
 */
export type SimplifyCanopy1 = boolean;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier11 = string;
/**
 * UNDOCUMENTED.
 */
export type CanopyHeight1 = number;
/**
 * UNDOCUMENTED.
 */
export type BaseRadius1 = number;
/**
 * UNDOCUMENTED.
 */
export type RadiusStepModifier = number;
/**
 * UNDOCUMENTED.
 */
export type CoreWidth1 = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier12 = string;
/**
 * UNDOCUMENTED.
 */
export type CanopyHeight2 = number;
/**
 * UNDOCUMENTED.
 */
export type BaseRadius2 = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier13 = string;
/**
 * UNDOCUMENTED.
 */
export type CanopyHeight3 = number;
/**
 * UNDOCUMENTED.
 */
export type CoreWidth2 = number;
/**
 * UNDOCUMENTED.
 */
export type OuterRadius = number;
/**
 * UNDOCUMENTED.
 */
export type InnerRadius = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier14 = string;
/**
 * UNDOCUMENTED.
 */
export type LowerOffset = number;
/**
 * UNDOCUMENTED.
 */
export type UpperOffset = number;
/**
 * UNDOCUMENTED.
 */
export type MaxRadius = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier15 = string;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier16 = string;
/**
 * UNDOCUMENTED.
 */
export type NumSteps1 = number;
/**
 * UNDOCUMENTED.
 */
export type StepDirection1 = "down" | "up" | "out" | "away";
/**
 * UNDOCUMENTED.
 */
export type LogLength = number;
/**
 * UNDOCUMENTED.
 */
export type StumpHeight = number;
/**
 * UNDOCUMENTED.
 */
export type HeightModifier = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier17 = string;
/**
 * UNDOCUMENTED.
 */
export type LogDecorationFeature = string;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier18 = string;
/**
 * UNDOCUMENTED.
 */
export type NumSteps2 = number;
/**
 * UNDOCUMENTED.
 */
export type StepDirection2 = "down" | "up" | "out" | "away";
/**
 * UNDOCUMENTED.
 */
export type Base1 = number;
/**
 * UNDOCUMENTED.
 */
export type Variance = number;
/**
 * UNDOCUMENTED.
 */
export type Scale = number;
/**
 * UNDOCUMENTED.
 */
export type TrunkWidth1 = number;
/**
 * UNDOCUMENTED.
 */
export type Slope = number;
/**
 * UNDOCUMENTED.
 */
export type Density = number;
/**
 * UNDOCUMENTED.
 */
export type MinAltitudeFactor = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier19 = string;
/**
 * UNDOCUMENTED.
 */
export type WidthScale = number;
/**
 * UNDOCUMENTED.
 */
export type FoliageAltitudeFactor = number;
/**
 * UNDOCUMENTED.
 */
export type TrunkWidth2 = number;
/**
 * UNDOCUMENTED.
 */
export type Base2 = number;
/**
 * UNDOCUMENTED.
 */
export type Items = number;
/**
 * UNDOCUMENTED.
 */
export type Intervals1 = Items[];
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier20 = string;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier21 = string;
/**
 * UNDOCUMENTED.
 */
export type NumSteps3 = number;
/**
 * UNDOCUMENTED.
 */
export type StepDirection3 = "down" | "up" | "out" | "away";
/**
 * UNDOCUMENTED.
 */
export type BranchLength1 = number;
/**
 * UNDOCUMENTED.
 */
export type BranchSlope = number;
/**
 * UNDOCUMENTED.
 */
export type Min2 = number;
/**
 * UNDOCUMENTED.
 */
export type Max2 = number;
/**
 * UNDOCUMENTED.
 */
export type TrunkHeight3 = number;
/**
 * UNDOCUMENTED.
 */
export type HeightModifier1 = number;
/**
 * UNDOCUMENTED.
 */
export type CanBeSubmerged =
  | {
      max_depth?: MaxDepth;
    }
  | CanBeSubmerged1;
/**
 * UNDOCUMENTED.
 */
export type MaxDepth = number;
/**
 * UNDOCUMENTED.
 */
export type CanBeSubmerged1 = boolean;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier22 = string;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier23 = string;
/**
 * UNDOCUMENTED.
 */
export type NumSteps4 = number;
/**
 * UNDOCUMENTED.
 */
export type StepDirection4 = "down" | "up" | "out" | "away";
/**
 * UNDOCUMENTED.
 */
export type CanopySize1 = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier24 = string;
/**
 * UNDOCUMENTED.
 */
export type SimplifyCanopy2 = boolean;
/**
 * UNDOCUMENTED.
 */
export type Min3 = number;
/**
 * UNDOCUMENTED.
 */
export type Max3 = number;
/**
 * UNDOCUMENTED.
 */
export type MinWidth1 = number;
/**
 * UNDOCUMENTED.
 */
export type Rise1 = number;
/**
 * UNDOCUMENTED.
 */
export type Run1 = number;
/**
 * UNDOCUMENTED.
 */
export type VariationChance1 = ChanceInformation1 | number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier25 = string;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier26 = string;
/**
 * UNDOCUMENTED.
 */
export type NumSteps5 = number;
/**
 * UNDOCUMENTED.
 */
export type StepDirection5 = "down" | "up" | "out" | "away";
/**
 * UNDOCUMENTED.
 */
export type Height1 = number;
/**
 * UNDOCUMENTED.
 */
export type Radius1 = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier27 = string;
/**
 * UNDOCUMENTED.
 */
export type CanopyHeight4 = number;
/**
 * UNDOCUMENTED.
 */
export type BaseRadius3 = number;
/**
 * UNDOCUMENTED.
 */
export type CoreWidth3 = number;
/**
 * UNDOCUMENTED.
 */
export type SimplifyCanopy3 = boolean;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier28 = string;
/**
 * UNDOCUMENTED.
 */
export type CanopyHeight5 = number;
/**
 * UNDOCUMENTED.
 */
export type BaseRadius4 = number;
/**
 * UNDOCUMENTED.
 */
export type RadiusStepModifier1 = number;
/**
 * UNDOCUMENTED.
 */
export type CoreWidth4 = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier29 = string;
/**
 * UNDOCUMENTED.
 */
export type CanopyHeight6 = number;
/**
 * UNDOCUMENTED.
 */
export type BaseRadius5 = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier30 = string;
/**
 * UNDOCUMENTED.
 */
export type CanopyHeight7 = number;
/**
 * UNDOCUMENTED.
 */
export type CoreWidth5 = number;
/**
 * UNDOCUMENTED.
 */
export type OuterRadius1 = number;
/**
 * UNDOCUMENTED.
 */
export type InnerRadius1 = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier31 = string;
/**
 * UNDOCUMENTED.
 */
export type LowerOffset1 = number;
/**
 * UNDOCUMENTED.
 */
export type UpperOffset1 = number;
/**
 * UNDOCUMENTED.
 */
export type MaxRadius1 = number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier32 = string;
/**
 * UNDOCUMENTED.
 */
export type CanopyHeight8 = number;
/**
 * UNDOCUMENTED.
 */
export type CanopyRadius = number;
/**
 * UNDOCUMENTED.
 */
export type LeafPlacementAttempts = number;
/**
 * UNDOCUMENTED.
 */
export type Items1 = [] | [number] | [number, number];
/**
 * UNDOCUMENTED.
 */
export type LeafBlocks = Items1[];
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier20 = string;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier33 = string;
/**
 * How many blocks to increase the cave radius by, from the center point of the cave.
 */
export type WidthModifier1 = string | number;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier34 = string;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier21 = string;
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier35 = string;
/**
 * UNDOCUMENTED.
 */
export type ReplaceableBlocks = BlockIdentifier35[];
/**
 * A minecraft block identifier.
 */
export type BlockIdentifier36 = string;
/**
 * UNDOCUMENTED.
 */
export type VegetationFeature = string;
/**
 * UNDOCUMENTED.
 */
export type Surface1 = string;
/**
 * UNDOCUMENTED.
 */
export type Depth = number;
/**
 * UNDOCUMENTED.
 */
export type ExtraDeepBlockChance = number;
/**
 * UNDOCUMENTED.
 */
export type VerticalRange = number;
/**
 * UNDOCUMENTED.
 */
export type VegatationChance = number;
/**
 * UNDOCUMENTED.
 */
export type HorizontalRadius = number;
/**
 * UNDOCUMENTED.
 */
export type ExtraEgdeColumnChance = number;
/**
 * UNDOCUMENTED.
 */
export type Waterlogged = boolean;
/**
 * The name of this feature in the form `namespace_name:feature_name`. `feature_name` must match the filename.
 */
export type Identifier22 = string;
/**
 *  Collection of weighted features that placement will select from.
 *
 * @minItems 1
 */
export type Features2 = [Feature3, ...Feature3[]];
/**
 * Named reference to a feature.
 */
export type Feature3 = [] | [Feature4] | [Feature4, Weight2];
/**
 * Named reference to a feature.
 */
export type Feature4 = string;
/**
 * Weight used in random selection. Value is relative to other weights in the collection.
 */
export type Weight2 = number;

/**
 * Features are decorations scattered throughout the world. Things such as trees, plants, flowers, springs, ore, and coral are all features. Basically, if it isn't the terrain or a mob, it's probably a feature!
 */
export interface Features1130 {
  format_version: FormatVersion;
  "minecraft:aggregate_feature"?: AggregateFeature;
  "minecraft:beards_and_shavers"?: BeardsAndShavers;
  "minecraft:cave_carver_feature"?: CaveCarverFeature;
  "minecraft:conditional_list"?: ConditionalList;
  "minecraft:geode_feature"?: GeodeFeature;
  "minecraft:growing_plant_feature"?: GrowingPlantFeature;
  "minecraft:hell_cave_carver_feature"?: HellCaveCarverFeature;
  "minecraft:multiface_feature"?: MultifaceFeature;
  "minecraft:ore_feature"?: OreFeature;
  "minecraft:rect_layout"?: RectLayout;
  "minecraft:scan_surface"?: RectLayout1;
  "minecraft:scatter_feature"?: ScatterFeature;
  "minecraft:search_feature"?: SearchFeature;
  "minecraft:sequence_feature"?: SequenceFeature;
  "minecraft:single_block_feature"?: SingleBlockFeature;
  "minecraft:snap_to_surface_feature"?: SnapToSurfaceFeature;
  "minecraft:structure_template_feature"?: StructureTemplateFeature;
  "minecraft:tree_feature"?: StructureTemplateFeature1;
  "minecraft:underwater_cave_carver_feature"?: UnderwaterCaveCarverFeature;
  "minecraft:vegetation_patch_feature"?: VegetationPatchFeature;
  "minecraft:weighted_random_feature"?: WeightedRandomFeature;
}
/**
 * 'minecraft:aggregate_feature` places a collection of features in an arbitary order. All features in the collection use the same input position. Features should not depend on each other, as there is no guarantee on the order the features will be placed.
 *  Succeeds if: At lease one feature is placed successfully.
 *  Fails if: All features fail to be placed.
 */
export interface AggregateFeature {
  description: Description;
  features: Features;
  early_out?: EarlyOut;
}
/**
 * UNDOCUMENTED.
 */
export interface Description {
  identifier: Identifier;
  [k: string]: unknown;
}
/**
 * `minecraft:beards_and_shavers` will build a `beard` or `shave` out space so as to provide a clear space for a feature to place.
 * Succeeds if: a beard/shave is made (this should always happen).
 * Fails if: will always return placement pos, but interior feature placement not guaranteed.
 */
export interface BeardsAndShavers {
  description: Description1;
  places_feature: PlacesFeature;
  bounding_box_min: BoundingBoxMin;
  bounding_box_max: BoundingBoxMax;
  y_delta: YDelta;
  surface_block_type: SurfaceBlockType;
  subsurface_block_type: SubsurfaceBlockType;
  beard_raggedness_min?: BeardRaggednessMin;
  beard_raggedness_max?: BeardRaggednessMax;
}
/**
 * UNDOCUMENTED.
 */
export interface Description1 {
  identifier: Identifier1;
  [k: string]: unknown;
}
/**
 * `minecraft:cave_carver_feature` carves a cave through the world in the current chunk, and in every chunk around the current chunk in an 8 radial pattern. This feature will also only work when placed specifically in the pass `pregeneration_pass`.
 */
export interface CaveCarverFeature {
  description: Description2;
  fill_with?: FillWith;
  width_modifier?: WidthModifier;
}
/**
 * UNDOCUMENTED.
 */
export interface Description2 {
  identifier: Identifier2;
  [k: string]: unknown;
}
/**
 * `minecraft:conditional_list` Places the first suitable feature within a collection.
 * These conditional features will be evaluated in order.
 * Succeeds if: A condition is successfully resolved.
 * Fails if: No condition is successfully resolved.
 * Example use: assigning a feature to an expression
 */
export interface ConditionalList {
  description: Description3;
  conditional_features: ConditionalFeatures;
  early_out_scheme?: EarlyOutScheme;
}
/**
 * UNDOCUMENTED.
 */
export interface Description3 {
  identifier: Identifier3;
  [k: string]: unknown;
}
/**
 * A Feature, and their associated Conditions, for attempted placement. These features will be evaluated as ordered.
 */
export interface ConditionalFeature {
  places_feature: PlacesFeature1;
  condition: Condition;
}
/**
 * `minecraft:geode_feature` generates a rock formation to simulate a geode. Each layer of, and block within, the geode can be replaced.
 * Succeeds if: At least one block within the geode is placed.
 * Fails if: All blocks within the geode fail to be placed.
 */
export interface GeodeFeature {
  description: Description4;
  filler: Filler;
  inner_layer: InnerLayer;
  alternate_inner_layer: AlternateInnerLayer;
  middle_layer: MiddleLayer;
  outer_layer: OuterLayer;
  inner_placements?: InnerPlacements;
  min_outer_wall_distance: MinimumOuterWallDistance;
  max_outer_wall_distance: MaximumOuterWallDistance;
  min_distribution_points: MinimumDistributionPoints;
  max_distribution_points: MaximumDistributionPoints;
  min_point_offset: MinimumPointOffset;
  max_point_offset: MaximumPointOffset;
  max_radius: MaximumRadius;
  crack_point_offset: CrackPointOffset;
  generate_crack_chance: GenerateCrackChance;
  base_crack_size: BaseCrackSize;
  noise_multiplier: NoiseMultiplier;
  use_potential_placements_chance: UsePotentialPlacementsChance;
  use_alternate_layer0_chance: UseAlternateLayer0Chance;
  placements_require_layer0_alternate: PlacementsRequireLayer0Alternate;
  invalid_blocks_threshold: InvalidBlocksThreshold;
}
/**
 * UNDOCUMENTED.
 */
export interface Description4 {
  identifier: Identifier4;
  [k: string]: unknown;
}
/**
 * `minecraft:growing_plant_feature` places a growing plant in the world. A growing plant is a column that is anchored either to the ceiling or the floor, based on its growth direction.
 * The growing plant has a body and a head, where the head is the tip of the plant, and the body consists of the remainder blocks.
 * This feature can be used to define growing plants with variable body and head blocks, e.g. Cave Vines.
 */
export interface GrowingPlantFeature {
  description: Description5;
  age?: Age;
  height_distribution: HeightDistribution;
  growth_direction: GrowthDirection;
  body_blocks: BodyBlocks;
  head_blocks: HeadBlocks;
  allow_water?: AllowWater;
}
/**
 * UNDOCUMENTED.
 */
export interface Description5 {
  identifier: Identifier5;
  [k: string]: unknown;
}
/**
 * A range.
 */
export interface Range {
  range_max: RangeMax;
  range_min: RangeMin;
  [k: string]: unknown;
}
/**
 * `minecraft:hell_cave_carver_feature` carves a cave through the Nether in the current chunk, and in every chunk around the current chunk in an 8 radial pattern.This feature will also only work when placed specifically in the pass `pregeneration_pass`.
 */
export interface HellCaveCarverFeature {
  description: Description6;
  fill_with?: Identifier7;
  width_modifier?: Identifier8;
}
/**
 * UNDOCUMENTED.
 */
export interface Description6 {
  identifier: Identifier6;
  [k: string]: unknown;
}
/**
 * `minecraft:multiface_feature` places one or a few multiface blocks on floors/walls/ceilings. Despite the name, any block can be placed by this feature. During placement, existing world blocks are checked to see if this feature can be placed on them based on the list provided in the `can_place_on` field. If no `can_replace_on` field is specified, the `place_block` block can be placed on any existing block.
 * This feature will also try to spread the `place_block` block around the location in world the feature is placed.
 * Succeeds if: At least one block is successfully placed.
 * Fails if: All block placements fail.
 */
export interface MultifaceFeature {
  description: Description7;
  places_block: PlacesBlock;
  search_range: SearchRange;
  can_place_on_floor: CanPlaceOnFloor;
  can_place_on_ceiling: CanPlaceOnCeiling;
  can_place_on_wall: CanPlaceOnWall;
  chance_of_spreading: ChanceOfSpreading;
  can_place_on?: CanPlaceOn;
}
/**
 * UNDOCUMENTED.
 */
export interface Description7 {
  identifier: Identifier9;
  [k: string]: unknown;
}
/**
 * `minecraft:ore_feature` places a vein of blocks to simulate ore deposits. Despite the name, any block can be placed by this feature. During placement, existing world blocks are checked to see if they can be replaced by the new ore block based on the list provided in the `may_replace` field of a `replace_rules` entry. If no `may_replace` field is specified in a `replace_rule` entry, the ore block can replace any existing block.
 * Succeeds if: At least one ore block is successfully placed.
 * Fails if: All ore block placements fail.
 */
export interface OreFeature {
  description: Description8;
  count: Count;
  replace_rules?: ReplaceRules;
}
/**
 * UNDOCUMENTED.
 */
export interface Description8 {
  identifier: Identifier10;
  [k: string]: unknown;
}
/**
 * If a rule is resolved, the rest will not be resolved for that block position.
 */
export interface RepalceRule {
  places_block: PlacesBlock1;
  may_replace?: MayReplace;
  [k: string]: unknown;
}
/**
 * `minecraft:rect_layout` places a vein of blocks to simulate ore deposits. Despite the name, any block can be placed by this feature. During placement, existing world blocks are checked to see if they can be replaced by the new ore block based on the list provided in the `may_replace` field of a `replace_rules` entry. If no `may_replace` field is specified in a `replace_rule` entry, the ore block can replace any existing block.
 * Succeeds if: At least one ore block is successfully placed.
 * Fails if: All ore block placements fail.
 */
export interface RectLayout {
  description: Description9;
  ratio_of_empty_space?: RatioOfEmptySpace;
  feature_areas: FeatureAreas;
}
/**
 * UNDOCUMENTED.
 */
export interface Description9 {
  identifier: Identifier11;
  [k: string]: unknown;
}
/**
 * UNDOCUMENTED.
 */
export interface FeatureArea {
  feature?: Feature1;
  area_dimensions?: AreaDimensions;
}
/**
 * `minecraft:scan_surface` scans the surface of a Chunk, calling place() on the surface of each block column.
 * Succeeds if: A Feature was successfully placed during the scan.
 * Fails if: No Feature was placed during the course of the scan.
 */
export interface RectLayout1 {
  description: Description10;
  scan_surface_feature: ScanSurfaceFeature;
}
/**
 * UNDOCUMENTED.
 */
export interface Description10 {
  identifier: Identifier12;
  [k: string]: unknown;
}
/**
 * `minecraft:scatter_feature` scatters a feature throughout a chunk. The `x`, `y`, and `z` fields are per-coordinate parameters.
 * Note that coordinates represent an offset from the input position, not an absolute position. Coordinates may be a single value, a random distribution, or molang expression that resolves to a numeric value. The `coordinate_eval_order` field is provided for finer control of coordinate resolution (particularly when using the `grid` distribution). `iterations` controls how many individual placements should occur if the `scatter_chance` check succeeds. The `scatter_chance` check happens once, so either all placements will run or none will.
 * Succeeds if: At least one feature placement succeeds.
 * Fails if: All feature placements fail.
 */
export interface ScatterFeature {
  description: Description11;
  places_feature: PlacesFeature2;
  project_input_to_floor?: ProjectInputToFloor;
  iterations?: Iterations;
  scatter_chance?: ScatterChance;
  coordinate_eval_order?: CoordinateEvalOrder;
  x?: X2;
  y?: X3;
  z?: X4;
}
/**
 * UNDOCUMENTED.
 */
export interface Description11 {
  identifier: Identifier13;
  [k: string]: unknown;
}
/**
 * `minecraft:search_feature` sweeps a volume searching for a valid placement location for its referenced feature. The `search_volume` field specifies the axis-aligned bounding box that defines the boundaries of the search. The search sweeps along the axis defined by the `search_axis` field, layer by layer. For example, if `search_axis` = '-x', blocks with greater x values will be checked before blocks with lower x values. Each layer is searched from the bottom-left to the top-right before moving to the next layer along the axis. By default, only one valid position must be found, but this can be altered by specifying the `required_successes` field. If fewer than the required successes are found, no placement will occur.
 * Succeeds if: The number of valid positions is equal to the value specified by `required_successes`.
 * Fails if: The number of valid positions is less than the value specified by `required_successes`.
 */
export interface SearchFeature {
  description: Description12;
  places_feature?: PlacesFeature3;
  search_volume?: PlacesFeature4;
  search_axis: SearchAxis;
  required_successes?: RequiredSuccesses;
}
/**
 * UNDOCUMENTED.
 */
export interface Description12 {
  identifier: Identifier14;
  [k: string]: unknown;
}
/**
 * Axis-aligned bounding box that will be searched for valid placement positions. Expressed as offsets from the input position.
 */
export interface PlacesFeature4 {
  max: Max;
  min: Min;
}
/**
 * `minecraft:sequence_feature` places a collection of features sequentially, in the order they appear in data. The output position of the previous feature is used as the input position for the next. For example, a tree feature is placed at (0, 0, 0) and places blocks up to (0, 10, 0). The next feature in the sequence begins at (0, 10, 0).
 * Succeeds if: All features in the sequence are successfully placed.
 * Fails if: Any feature in the sequence fails to be placed. Features that have not yet been placed at the time of failure are skipped.
 */
export interface SequenceFeature {
  description: Description13;
  features: Features1;
}
/**
 * UNDOCUMENTED.
 */
export interface Description13 {
  identifier: Identifier15;
  [k: string]: unknown;
}
/**
 * `minecraft:single_block_feature` places a single block in the world. The `may_place_on` and `may_replace` fields are allowlists which specify where the block can be placed. If these fields are omitted, the block can be placed anywhere. The block's internal survivability and placement rules can optionally be enforced with the `enforce_survivability_rules` and `enforce_placement_rules` fields. These rules are specified per-block and are typically designed to produce high quality gameplay or natural behavior. However, enabling this enforcement may make it harder to debug placement failures.
 *  Succeeds if: The block is successfully placed in the world.
 *  Fails if: The block fails to be placed.
 */
export interface SingleBlockFeature {
  description: Description14;
  places_block: BlockIdentifier1;
  enforce_placement_rules: EnforcePlacementRules;
  enforce_survivability_rules: EnforceSurvivabilityRules;
  may_attach_to?: MayAttachTo;
  may_replace?: MayReplace1;
}
/**
 * UNDOCUMENTED.
 */
export interface Description14 {
  identifier: Identifier16;
  [k: string]: unknown;
}
/**
 * UNDOCUMENTED.
 */
export interface MayAttachTo {
  min_sides_must_attach?: MinimumSidesMustAttach;
  auto_rotate?: AutoRotate;
  top?: Top;
  bottom?: Bottom;
  north?: North;
  south?: South;
  east?: East;
  west?: West;
  all?: All;
  sides?: Sides;
}
/**
 * UNDOCUMENTED.
 */
export interface MinimumSidesMustAttach {
  [k: string]: unknown;
}
/**
 * Automatically rotate the block to attach sensibly.
 */
export interface AutoRotate {
  [k: string]: unknown;
}
/**
 * `minecraft:snap_to_surface_feature` snaps the y-value of a feature placement pos to the floor or the ceiling within the provided `vertical_search_range`. The placement biome is preserved.
 * If the snap position goes outside of the placement biome, placement will fail.
 */
export interface SnapToSurfaceFeature {
  description: Description15;
  feature_to_snap: FeatureToSnap;
  vertical_search_range: VerticalSearchRange;
  surface?: Surface;
}
/**
 * UNDOCUMENTED.
 */
export interface Description15 {
  identifier: Identifier17;
  [k: string]: unknown;
}
/**
 * `minecraft:structure_template_feature` places a structure in the world. The structure must be stored as a .mcstructure file in the `structures` subdirectory of a behavior pack. It is possible to reference structures that are part of other behavior packs, they do not need to come from the same behavior pack as this feature. Constraints can be defined to specify where the structure is allowed to be placed. During placement, the feature will search for a position within the 'adjustment_radius' that satisfies all constraints. If none are found, the structure will not be placed.
 * Succeeds if: The structure is placed in the world.
 * Fails if: The structure fails to be placed within the world.
 */
export interface StructureTemplateFeature {
  description: Description16;
  structure_name: StructureName;
  adjustment_radius?: AdjustmentRadius;
  facing_direction?: FacingDirection;
  /**
   * Specific constraints that must be satisfied when placing this structure.
   */
  constraints: {
    grounded?: Grounded;
    unburied?: Unburied;
    block_intersection?: Unburied1;
  };
}
/**
 * UNDOCUMENTED.
 */
export interface Description16 {
  identifier: Identifier18;
  [k: string]: unknown;
}
/**
 * When specified, ensures the structure is on the ground.
 */
export interface Grounded {}
/**
 * When specified, ensures the structure has air above it.
 */
export interface Unburied {}
/**
 * When specified, ensures the structure has air above it.
 */
export interface Unburied1 {
  block_allowlist?: BlockAllowlist;
  block_whitelist?: BlockWhitelist;
}
/**
 * Feature type 'minecraft:tree_feature' has not yet been documented.
 */
export interface StructureTemplateFeature1 {
  description: Description17;
  base_block?: BaseBlock;
  base_cluster?: BaseCluster;
  may_grow_on?: MayGrowOn;
  may_replace?: MayGrowOn1;
  may_grow_through?: MayGrowOn2;
  acacia_trunk?: AcaciaTrunk;
  fallen_trunk?: FallenTrunk;
  fancy_trunk?: FancyTrunk;
  mega_trunk?: MegaTrunk;
  trunk?: Trunk;
  acacia_canopy?: AcaciaCanopy1;
  canopy?: Canopy1;
  fancy_canopy?: FancyCanopy1;
  mega_canopy?: MegaCanopy1;
  mega_pine_canopy?: MegaPineCanopy1;
  pine_canopy?: PineCanopy1;
  roofed_canopy?: RoofedCanopy1;
  spruce_canopy?: SpruceCanopy1;
  random_spread_canopy?: RandomSpreadCanopy;
}
/**
 * UNDOCUMENTED.
 */
export interface Description17 {
  identifier: Identifier19;
  [k: string]: unknown;
}
/**
 * UNDOCUMENTED.
 */
export interface BaseCluster {
  may_replace: MayReplace2;
  num_clusters: NumClusters;
  cluster_radius: ClustersRadius;
}
/**
 * UNDOCUMENTED.
 */
export interface AcaciaTrunk {
  trunk_width?: TrunkWidth;
  trunk_height?: TrunkHeight;
  trunk_lean?: {
    [k: string]: unknown;
  };
  trunk_block?: BlockIdentifier6;
  branches?: Branches;
}
/**
 * UNDOCUMENTED.
 */
export interface TrunkHeight {
  base?: Base;
  intervals?: Intervals;
  min_height_for_canopy?: MinimumHeightForCanopy;
}
/**
 * UNDOCUMENTED.
 */
export interface Branches {
  branch_length?: BranchLength;
  branch_position?: BranchPosition;
  branch_chance?: ChanceInformation;
  branch_canopy?: BranchCanopy;
  trunk_decoration?: TrunkDecoration;
}
/**
 * UNDOCUMENTED.
 */
export interface ChanceInformation {
  numerator?: Numerator1;
  denominator?: Denominator1;
}
/**
 * UNDOCUMENTED.
 */
export interface BranchCanopy {
  acacia_canopy?: AcaciaCanopy;
  canopy?: Canopy;
  fancy_canopy?: FancyCanopy;
  mega_canopy?: MegaCanopy;
  mega_pine_canopy?: MegaPineCanopy;
  pine_canopy?: PineCanopy;
  roofed_canopy?: RoofedCanopy;
  spruce_canopy?: SpruceCanopy;
}
/**
 * UNDOCUMENTED.
 */
export interface AcaciaCanopy {
  canopy_size?: CanopySize;
  leaf_block?: BlockIdentifier7;
  simplify_canopy?: SimplifyCanopy;
}
/**
 * UNDOCUMENTED.
 */
export interface Canopy {
  canopy_offset?: CanopyOffset;
  min_width?: MinWidth;
  canopy_slope?: CanopySlope;
  variation_chance?: VariationChance;
  leaf_block?: BlockIdentifier8;
  canopy_decoration?: CanopyDecoration;
}
/**
 * UNDOCUMENTED.
 */
export interface CanopyOffset {
  min?: Min1;
  max?: Max1;
}
/**
 * UNDOCUMENTED.
 */
export interface CanopySlope {
  rise?: Rise;
  run?: Run;
}
/**
 * UNDOCUMENTED.
 */
export interface ChanceInformation1 {
  numerator?: Numerator1;
  denominator?: Denominator1;
}
/**
 * UNDOCUMENTED.
 */
export interface CanopyDecoration {
  decoration_chance?: ChanceInformation2;
  decoration_block?: BlockIdentifier9;
  num_steps?: NumSteps;
  step_direction?: StepDirection;
}
/**
 * UNDOCUMENTED.
 */
export interface ChanceInformation2 {
  numerator?: Numerator1;
  denominator?: Denominator1;
}
/**
 * UNDOCUMENTED.
 */
export interface FancyCanopy {
  height?: Height;
  radius?: Radius;
  leaf_block?: BlockIdentifier10;
}
/**
 * UNDOCUMENTED.
 */
export interface MegaCanopy {
  canopy_height?: CanopyHeight;
  base_radius?: BaseRadius;
  core_width?: CoreWidth;
  simplify_canopy?: SimplifyCanopy1;
  leaf_block?: BlockIdentifier11;
}
/**
 * UNDOCUMENTED.
 */
export interface MegaPineCanopy {
  canopy_height?: CanopyHeight1;
  base_radius?: BaseRadius1;
  radius_step_modifier?: RadiusStepModifier;
  core_width?: CoreWidth1;
  leaf_block?: BlockIdentifier12;
}
/**
 * UNDOCUMENTED.
 */
export interface PineCanopy {
  canopy_height?: CanopyHeight2;
  base_radius?: BaseRadius2;
  leaf_block?: BlockIdentifier13;
}
/**
 * UNDOCUMENTED.
 */
export interface RoofedCanopy {
  canopy_height?: CanopyHeight3;
  core_width?: CoreWidth2;
  outer_radius?: OuterRadius;
  inner_radius?: InnerRadius;
  leaf_block?: BlockIdentifier14;
}
/**
 * UNDOCUMENTED.
 */
export interface SpruceCanopy {
  lower_offset?: LowerOffset;
  upper_offset?: UpperOffset;
  max_radius?: MaxRadius;
  leaf_block?: BlockIdentifier15;
}
/**
 * UNDOCUMENTED.
 */
export interface TrunkDecoration {
  decoration_chance?: ChanceInformation3;
  decoration_block?: BlockIdentifier16;
  num_steps?: NumSteps1;
  step_direction?: StepDirection1;
}
/**
 * UNDOCUMENTED.
 */
export interface ChanceInformation3 {
  numerator?: Numerator1;
  denominator?: Denominator1;
}
/**
 * UNDOCUMENTED.
 */
export interface FallenTrunk {
  log_length?: LogLength;
  stump_height?: StumpHeight;
  height_modifier?: HeightModifier;
  trunk_block?: BlockIdentifier17;
  log_decoration_feature?: LogDecorationFeature;
  trunk_decoration?: TrunkDecoration1;
}
/**
 * UNDOCUMENTED.
 */
export interface TrunkDecoration1 {
  decoration_chance?: ChanceInformation4;
  decoration_block?: BlockIdentifier18;
  num_steps?: NumSteps2;
  step_direction?: StepDirection2;
}
/**
 * UNDOCUMENTED.
 */
export interface ChanceInformation4 {
  numerator?: Numerator1;
  denominator?: Denominator1;
}
/**
 * UNDOCUMENTED.
 */
export interface FancyTrunk {
  trunk_height?: TrunkHeight1;
  trunk_width?: TrunkWidth1;
  branches?: Branches1;
  trunk_block?: BlockIdentifier19;
  width_scale?: WidthScale;
  foliage_altitude_factor?: FoliageAltitudeFactor;
}
/**
 * UNDOCUMENTED.
 */
export interface TrunkHeight1 {
  base?: Base1;
  variance?: Variance;
  scale?: Scale;
}
/**
 * UNDOCUMENTED.
 */
export interface Branches1 {
  slope?: Slope;
  density?: Density;
  min_altitude_factor?: MinAltitudeFactor;
}
/**
 * UNDOCUMENTED.
 */
export interface MegaTrunk {
  trunk_width?: TrunkWidth2;
  trunk_height?: TrunkHeight2;
  trunk_block?: BlockIdentifier20;
  trunk_decoration?: TrunkDecoration2;
  branches?: Branches2;
}
/**
 * UNDOCUMENTED.
 */
export interface TrunkHeight2 {
  base?: Base2;
  intervals?: Intervals1;
}
/**
 * UNDOCUMENTED.
 */
export interface TrunkDecoration2 {
  decoration_chance?: ChanceInformation5;
  decoration_block?: BlockIdentifier21;
  num_steps?: NumSteps3;
  step_direction?: StepDirection3;
}
/**
 * UNDOCUMENTED.
 */
export interface ChanceInformation5 {
  numerator?: Numerator1;
  denominator?: Denominator1;
}
/**
 * UNDOCUMENTED.
 */
export interface Branches2 {
  branch_length?: BranchLength1;
  branch_slope?: BranchSlope;
  /**
   * UNDOCUMENTED.
   */
  branch_interval?: number;
  branch_altitude_factor?: BranchAltitudeFactor;
  branch_canopy?: BranchCanopy1;
}
/**
 * UNDOCUMENTED.
 */
export interface BranchAltitudeFactor {
  min?: Min2;
  max?: Max2;
}
/**
 * UNDOCUMENTED.
 */
export interface BranchCanopy1 {
  acacia_canopy?: AcaciaCanopy;
  canopy?: Canopy;
  fancy_canopy?: FancyCanopy;
  mega_canopy?: MegaCanopy;
  mega_pine_canopy?: MegaPineCanopy;
  pine_canopy?: PineCanopy;
  roofed_canopy?: RoofedCanopy;
  spruce_canopy?: SpruceCanopy;
}
/**
 * UNDOCUMENTED.
 */
export interface Trunk {
  trunk_height?: TrunkHeight3;
  height_modifier?: HeightModifier1;
  can_be_submerged?: CanBeSubmerged;
  trunk_block?: BlockIdentifier22;
  trunk_decoration?: TrunkDecoration3;
}
/**
 * UNDOCUMENTED.
 */
export interface TrunkDecoration3 {
  decoration_chance?: ChanceInformation6;
  decoration_block?: BlockIdentifier23;
  num_steps?: NumSteps4;
  step_direction?: StepDirection4;
}
/**
 * UNDOCUMENTED.
 */
export interface ChanceInformation6 {
  numerator?: Numerator1;
  denominator?: Denominator1;
}
/**
 * UNDOCUMENTED.
 */
export interface AcaciaCanopy1 {
  canopy_size?: CanopySize1;
  leaf_block?: BlockIdentifier24;
  simplify_canopy?: SimplifyCanopy2;
}
/**
 * UNDOCUMENTED.
 */
export interface Canopy1 {
  canopy_offset?: CanopyOffset1;
  min_width?: MinWidth1;
  canopy_slope?: CanopySlope1;
  variation_chance?: VariationChance1;
  leaf_block?: BlockIdentifier25;
  canopy_decoration?: CanopyDecoration1;
}
/**
 * UNDOCUMENTED.
 */
export interface CanopyOffset1 {
  min?: Min3;
  max?: Max3;
}
/**
 * UNDOCUMENTED.
 */
export interface CanopySlope1 {
  rise?: Rise1;
  run?: Run1;
}
/**
 * UNDOCUMENTED.
 */
export interface CanopyDecoration1 {
  decoration_chance?: ChanceInformation7;
  decoration_block?: BlockIdentifier26;
  num_steps?: NumSteps5;
  step_direction?: StepDirection5;
}
/**
 * UNDOCUMENTED.
 */
export interface ChanceInformation7 {
  numerator?: Numerator1;
  denominator?: Denominator1;
}
/**
 * UNDOCUMENTED.
 */
export interface FancyCanopy1 {
  height?: Height1;
  radius?: Radius1;
  leaf_block?: BlockIdentifier27;
}
/**
 * UNDOCUMENTED.
 */
export interface MegaCanopy1 {
  canopy_height?: CanopyHeight4;
  base_radius?: BaseRadius3;
  core_width?: CoreWidth3;
  simplify_canopy?: SimplifyCanopy3;
  leaf_block?: BlockIdentifier28;
}
/**
 * UNDOCUMENTED.
 */
export interface MegaPineCanopy1 {
  canopy_height?: CanopyHeight5;
  base_radius?: BaseRadius4;
  radius_step_modifier?: RadiusStepModifier1;
  core_width?: CoreWidth4;
  leaf_block?: BlockIdentifier29;
}
/**
 * UNDOCUMENTED.
 */
export interface PineCanopy1 {
  canopy_height?: CanopyHeight6;
  base_radius?: BaseRadius5;
  leaf_block?: BlockIdentifier30;
}
/**
 * UNDOCUMENTED.
 */
export interface RoofedCanopy1 {
  canopy_height?: CanopyHeight7;
  core_width?: CoreWidth5;
  outer_radius?: OuterRadius1;
  inner_radius?: InnerRadius1;
  leaf_block?: BlockIdentifier31;
}
/**
 * UNDOCUMENTED.
 */
export interface SpruceCanopy1 {
  lower_offset?: LowerOffset1;
  upper_offset?: UpperOffset1;
  max_radius?: MaxRadius1;
  leaf_block?: BlockIdentifier32;
}
/**
 * UNDOCUMENTED.
 */
export interface RandomSpreadCanopy {
  canopy_height?: CanopyHeight8;
  canopy_radius?: CanopyRadius;
  leaf_placement_attempts?: LeafPlacementAttempts;
  leaf_blocks?: LeafBlocks;
}
/**
 * 'minecraft:underwater_cave_carver_feature' carves a cave through the world in the current chunk, and in every chunk around the current chunk in an 8 radial pattern.This feature will specifically target creating caves only below sea level.
 * This feature will also only work when placed specifically in the pass `pregeneration_pass`.
 */
export interface UnderwaterCaveCarverFeature {
  description: Description18;
  fill_with?: BlockIdentifier33;
  width_modifier?: WidthModifier1;
  replace_air_with?: BlockIdentifier34;
}
/**
 * UNDOCUMENTED.
 */
export interface Description18 {
  identifier: Identifier20;
  [k: string]: unknown;
}
/**
 * Feature type `minecraft:vegetation_patch_feature` has not yet been documented.
 */
export interface VegetationPatchFeature {
  description: Description19;
  replaceable_blocks?: ReplaceableBlocks;
  ground_block?: BlockIdentifier36;
  vegetation_feature?: VegetationFeature;
  surface?: Surface1;
  depth?: Depth;
  extra_deep_block_chance?: ExtraDeepBlockChance;
  vertical_range?: VerticalRange;
  vegetation_chance?: VegatationChance;
  horizontal_radius?: HorizontalRadius;
  extra_edge_column_chance?: ExtraEgdeColumnChance;
  waterlogged?: Waterlogged;
}
/**
 * UNDOCUMENTED.
 */
export interface Description19 {
  identifier: Identifier21;
  [k: string]: unknown;
}
/**
 * 'minecraft:weighted_random_feature' randomly selects and places a feature based on a weight value. Weights are relative, with higher values making selection more likely.
 * Succeeds if: The selected feature is placed.
 * Fails if: The selected feature fails to be placed.
 */
export interface WeightedRandomFeature {
  description: Description20;
  features: Features2;
}
/**
 * UNDOCUMENTED.
 */
export interface Description20 {
  identifier: Identifier22;
  [k: string]: unknown;
}
